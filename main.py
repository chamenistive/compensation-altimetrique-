"""
Script principal pour la compensation altim√©trique.

Application console utilisant les modules refactoris√©s pour d√©montrer
le pipeline complet avec une pr√©cision garantie de 2mm.

Pipeline:
1. Import et validation des donn√©es
2. Calculs pr√©liminaires
3. Compensation par moindres carr√©s
4. Validation et rapport final

Auteur: Syst√®me de Compensation Altim√©trique
Version: 1.0 (Modularis√©)
Pr√©cision: 2mm
"""

import sys
import argparse
from pathlib import Path
import pandas as pd
import numpy as np
from typing import Optional, Tuple

# Import des modules d√©velopp√©s
# from src.data_importer import DataImporter, quick_import
# from src.calculator import LevelingCalculator, quick_leveling_calculation
# from src.compensator import LevelingCompensator, quick_compensation
# from src.validators import PrecisionValidator
# from src.exceptions import *

# Import des modules d√©velopp√©s
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), 'src'))

from data_importer import DataImporter
from calculator import LevelingCalculator
from compensator import LevelingCompensator
from validators import PrecisionValidator
from exceptions import *
from atmospheric_corrections import (
    AtmosphericCorrector, AtmosphericConditions, create_standard_conditions
)
from visualizer import LevelingVisualizer
from utils import (
    quick_import, quick_leveling_calculation, quick_compensation, quick_visualization
)


class LevelingApplication:
    """
    Application principale de compensation altim√©trique.
    
    Orchestre le pipeline complet avec gestion d'erreurs robuste
    et interface utilisateur console conviviale.
    """
    
    def __init__(self, precision_mm: float = 2.0):
        """
        Initialisation de l'application.
        
        Args:
            precision_mm: Pr√©cision cible en millim√®tres
        """
        self.precision_mm = precision_mm
        self.version = "1.0 (Modularis√©)"
        
        # Modules principaux
        self.data_importer = DataImporter()
        # Cr√©er conditions atmosph√©riques pour la r√©gion
        atmospheric_conditions = create_standard_conditions("sahel")  # Adapt√© pour l'Afrique
        self.calculator = LevelingCalculator(
            precision_mm, 
            apply_atmospheric_corrections=True,
            atmospheric_conditions=atmospheric_conditions
        )
        self.compensator = LevelingCompensator(precision_mm)
        self.validator = PrecisionValidator(precision_mm)
        self.visualizer = LevelingVisualizer(precision_mm)
        
        # Stockage des r√©sultats
        self.imported_data = None
        self.calculation_results = None
        self.compensation_results = None
    
    def print_header(self):
        """Affichage de l'en-t√™te de l'application."""
        print(f"""
{'='*80}
    SYST√àME DE COMPENSATION ALTIM√âTRIQUE
    Version: {self.version}
    Pr√©cision cible: {self.precision_mm} mm
{'='*80}
""")
    
    def run_interactive(self):
        """Mode interactif console."""
        self.print_header()
        
        try:
            # √âtape 1: Import des donn√©es
            print("\nüîÑ √âTAPE 1: IMPORTATION DES DONN√âES")
            print("-" * 50)
            
            data_file = self._get_input_file()
            self.imported_data = self.data_importer.import_file(data_file)
            
            print("‚úÖ Import r√©ussi!")
            print(self.data_importer.get_import_summary())
            
            # √âtape 2: Configuration des altitudes
            print("\nüîÑ √âTAPE 2: CONFIGURATION DES ALTITUDES")
            print("-" * 50)
            
            initial_altitude, final_altitude = self._get_known_altitudes()
            
            # √âtape 3: Calculs pr√©liminaires
            print("\nüîÑ √âTAPE 3: CALCULS PR√âLIMINAIRES")
            print("-" * 50)
            
            self.calculation_results = self.calculator.calculate_complete_leveling(
                self.imported_data.dataframe,
                self.imported_data.ar_columns,
                self.imported_data.av_columns,
                self.imported_data.dist_columns,
                initial_altitude,
                final_altitude
            )
            
            print("‚úÖ Calculs pr√©liminaires termin√©s!")
            print(self.calculator.generate_calculation_report(self.calculation_results))
            
            # √âtape 4: Compensation par moindres carr√©s
            print("\nüîÑ √âTAPE 4: COMPENSATION PAR MOINDRES CARR√âS")
            print("-" * 50)
            
            # Pr√©paration des distances
            if self.imported_data.dist_columns:
                distances = self.imported_data.dataframe[self.imported_data.dist_columns[0]].values
            else:
                # Distances par d√©faut
                n_points = len(self.imported_data.dataframe)
                distances = np.full(n_points-1, 100.0)  # 100m par segment
            
            self.compensation_results = self.compensator.compensate(
                self.calculation_results,
                distances
            )
            
            print("‚úÖ Compensation termin√©e!")
            print(self.compensator.generate_compensation_report(self.compensation_results))
            
            # √âtape 5: Validation finale
            print("\nüîÑ √âTAPE 5: VALIDATION FINALE")
            print("-" * 50)
            
            validation_result = self.compensator.validate_compensation_quality(
                self.compensation_results
            )
            
            print(validation_result.get_summary())
            
            # √âtape 6: G√©n√©ration des visualisations
            print("\nüîÑ √âTAPE 6: G√âN√âRATION DES VISUALISATIONS")
            print("-" * 50)
            
            # V√©rifier si les visualisations sont activ√©es (par d√©faut OUI)
            generate_viz = getattr(self, 'enable_visualizations', True)
            
            if generate_viz:
                try:
                    # Cr√©er le dossier de visualisations
                    viz_dir = Path("./visualizations") / f"session_{pd.Timestamp.now().strftime('%Y%m%d_%H%M%S')}"
                    self.visualizer = LevelingVisualizer(self.precision_mm, viz_dir)
                    
                    # G√©n√©rer le rapport visuel complet
                    rapport_visuel = self.visualizer.create_complete_report(
                        self.calculation_results,
                        self.compensation_results
                    )
                    
                    print(f"‚úÖ Visualisations g√©n√©r√©es!")
                    print(f"üìÅ Dossier: {viz_dir}")
                    print(f"üìä Rapport: {rapport_visuel.name}")
                    
                except Exception as e:
                    print(f"‚ö†Ô∏è Erreur g√©n√©ration visualisations: {e}")
                    print("   Continuons sans les graphiques...")
            else:
                print("‚è≠Ô∏è Visualisations d√©sactiv√©es")
            
            # √âtape 7: Export des r√©sultats
            print("\nüîÑ √âTAPE 7: EXPORT DES R√âSULTATS")
            print("-" * 50)
            
            self._export_results()
            
            print("\nüéØ TRAITEMENT TERMIN√â AVEC SUCC√àS!")
            
        except Exception as e:
            self._handle_error(e)
    
    def run_batch(self, input_file: Path, initial_altitude: float,
                  final_altitude: Optional[float] = None,
                  output_dir: Optional[Path] = None):
        """
        Mode batch (traitement automatique).
        
        Args:
            input_file: Fichier de donn√©es
            initial_altitude: Altitude de r√©f√©rence
            final_altitude: Altitude finale (si cheminement ouvert)
            output_dir: Dossier de sortie
        """
        self.print_header()
        
        try:
            print(f"üìÅ Fichier d'entr√©e: {input_file}")
            print(f"üìè Altitude initiale: {initial_altitude} m")
            if final_altitude:
                print(f"üìè Altitude finale: {final_altitude} m")
            
            # Pipeline complet automatique
            print("\nüöÄ D√©marrage du traitement automatique...")
            
            # Import
            print("   1/4 Import des donn√©es...")
            self.imported_data = self.data_importer.import_file(input_file)
            
            # Calculs
            print("   2/4 Calculs pr√©liminaires...")
            self.calculation_results = self.calculator.calculate_complete_leveling(
                self.imported_data.dataframe,
                self.imported_data.ar_columns,
                self.imported_data.av_columns,
                self.imported_data.dist_columns,
                initial_altitude,
                final_altitude
            )
            
            # Compensation
            print("   3/4 Compensation par moindres carr√©s...")
            distances = (self.imported_data.dataframe[self.imported_data.dist_columns[0]].values
                        if self.imported_data.dist_columns
                        else np.full(len(self.imported_data.dataframe)-1, 100.0))
            
            self.compensation_results = self.compensator.compensate(
                self.calculation_results, distances
            )
            
            # Export et visualisations
            print("   4/5 G√©n√©ration des visualisations...")
            output_dir = output_dir or input_file.parent / "results"
            
            # Cr√©er les visualisations
            viz_dir = output_dir / "visualizations"
            visualizer = LevelingVisualizer(self.precision_mm, viz_dir)
            try:
                rapport_visuel = visualizer.create_complete_report(
                    self.calculation_results, self.compensation_results
                )
                print(f"       ‚úÖ Graphiques g√©n√©r√©s dans: {viz_dir}")
            except Exception as e:
                print(f"       ‚ö†Ô∏è Erreur visualisations: {e}")
            
            print("   5/5 Export des r√©sultats...")
            self._export_results(output_dir)
            
            print("\n‚úÖ TRAITEMENT BATCH TERMIN√â!")
            print(f"üìÅ R√©sultats dans: {output_dir}")
            
            # R√©sum√© final
            self._print_final_summary()
            
        except Exception as e:
            self._handle_error(e)
    
    def _get_input_file(self) -> Path:
        """S√©lection interactive du fichier d'entr√©e."""
        while True:
            file_path = input("\nüìÅ Chemin vers le fichier Excel/CSV: ").strip()
            
            if not file_path:
                print("‚ùå Veuillez sp√©cifier un chemin de fichier.")
                continue
            
            path = Path(file_path)
            
            if not path.exists():
                print(f"‚ùå Fichier non trouv√©: {path}")
                continue
            
            if not path.suffix.lower() in ['.xlsx', '.xls', '.csv']:
                print("‚ùå Format non support√©. Utilisez Excel (.xlsx, .xls) ou CSV.")
                continue
            
            return path
    
    def _get_known_altitudes(self) -> Tuple[float, Optional[float]]:
        """Saisie interactive des altitudes connues."""
        # Altitude initiale
        while True:
            try:
                initial_str = input(
                    f"\nüìè Altitude du point initial ({self.imported_data.initial_point}) [m]: "
                ).strip()
                initial_altitude = float(initial_str)
                break
            except ValueError:
                print("‚ùå Veuillez entrer une valeur num√©rique valide.")
        
        # Altitude finale (si cheminement ouvert)
        final_altitude = None
        if self.imported_data.initial_point != self.imported_data.final_point:
            print(f"\nüîÑ Cheminement ouvert d√©tect√©.")
            while True:
                try:
                    final_str = input(
                        f"üìè Altitude du point final ({self.imported_data.final_point}) [m]: "
                    ).strip()
                    final_altitude = float(final_str)
                    break
                except ValueError:
                    print("‚ùå Veuillez entrer une valeur num√©rique valide.")
        else:
            print(f"\nüîÑ Cheminement ferm√© d√©tect√©.")
        
        return initial_altitude, final_altitude
    
    def _export_results(self, output_dir: Optional[Path] = None):
        """Export des r√©sultats."""
        if output_dir is None:
            output_str = input("\nüìÅ Dossier de sortie (Entr√©e = dossier courant): ").strip()
            output_dir = Path(output_str) if output_str else Path.cwd()
        
        output_dir = Path(output_dir)
        output_dir.mkdir(exist_ok=True, parents=True)
        
        # Export Excel des r√©sultats
        results_df = self.compensator.export_results_to_dataframe(self.compensation_results)
        excel_path = output_dir / "resultats_compensation.xlsx"
        results_df.to_excel(excel_path, index=False)
        print(f"üìä R√©sultats Excel: {excel_path}")
        
        # Export rapport texte
        report_path = output_dir / "rapport_compensation.txt"
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write(self.calculator.generate_calculation_report(self.calculation_results))
            f.write("\n\n")
            f.write(self.compensator.generate_compensation_report(self.compensation_results))
        print(f"üìù Rapport: {report_path}")
        
        # Export donn√©es pr√©par√©es
        prepared_path = output_dir / "donnees_preparees.xlsx"
        self.data_importer.export_prepared_data(prepared_path, 'excel')
        print(f"üìã Donn√©es pr√©par√©es: {prepared_path}")
        
        print(f"\n‚úÖ Export termin√© dans: {output_dir}")
    
    def _print_final_summary(self):
        """Affichage du r√©sum√© final."""
        if not all([self.calculation_results, self.compensation_results]):
            return
        
        closure = self.calculation_results.closure_analysis
        stats = self.compensation_results.statistics
        
        print(f"""
{'='*80}
                        R√âSUM√â FINAL
{'='*80}

üéØ OBJECTIF PR√âCISION: {self.precision_mm} mm

üìä STATISTIQUES G√âN√âRALES:
   Points trait√©s: {len(self.compensation_results.adjusted_altitudes)}
   Type cheminement: {closure.traverse_type.value}
   Distance totale: {closure.total_distance_km:.3f} km

üìê PR√âCISION ATTEINTE:
   Erreur de fermeture: {abs(closure.closure_error_mm):.2f} mm
   Tol√©rance admise: ¬±{closure.tolerance_mm:.2f} mm
   Statut fermeture: {'‚úÖ ACCEPTABLE' if closure.is_acceptable else '‚ùå D√âPASSEMENT'}
   
   Correction maximale: {self.compensation_results.computation_metadata['max_correction_mm']:.2f} mm
   Objectif 2mm: {'‚úÖ ATTEINT' if self.compensation_results.computation_metadata['max_correction_mm'] <= 2.0 else '‚ùå D√âPASS√â'}

üìà QUALIT√â STATISTIQUE:
   œÉ‚ÇÄ (a posteriori): {stats.sigma_0_hat:.4f}
   Test œá¬≤ (poids): {'‚úÖ VALID√â' if stats.unit_weight_valid else '‚ùå REJET√â'}
   Fautes d√©tect√©es: {self.compensation_results.computation_metadata['blunder_detection']['suspect_count']}

üéØ VERDICT FINAL: {'‚úÖ SUCC√àS - PR√âCISION 2mm GARANTIE' if closure.is_acceptable and self.compensation_results.computation_metadata['max_correction_mm'] <= 2.0 else '‚ö†Ô∏è ATTENTION - V√âRIFIER R√âSULTATS'}

{'='*80}
""")
    
    def _handle_error(self, error: Exception):
        """Gestion centralis√©e des erreurs."""
        print(f"\n‚ùå ERREUR D√âTECT√âE: {type(error).__name__}")
        print(f"   Message: {str(error)}")
        
        if isinstance(error, LevelingError):
            if error.error_code:
                print(f"   Code: {error.error_code}")
            if error.details:
                print(f"   D√©tails: {error.details}")
        
        print(f"\nüí° SUGGESTIONS:")
        if isinstance(error, FileImportError):
            print("   ‚Ä¢ V√©rifiez que le fichier existe et n'est pas corrompu")
            print("   ‚Ä¢ Assurez-vous que le format est support√© (Excel/CSV)")
            print("   ‚Ä¢ V√©rifiez les permissions de lecture")
        
        elif isinstance(error, DataValidationError):
            print("   ‚Ä¢ V√©rifiez la structure des donn√©es (colonnes Matricule, AR, AV)")
            print("   ‚Ä¢ Assurez-vous d'avoir au moins 2 points de mesure")
            print("   ‚Ä¢ V√©rifiez que les paires AR/AV sont coh√©rentes")
        
        elif isinstance(error, CalculationError):
            print("   ‚Ä¢ V√©rifiez les valeurs num√©riques des lectures")
            print("   ‚Ä¢ Contr√¥lez les altitudes de r√©f√©rence")
            print("   ‚Ä¢ V√©rifiez la coh√©rence des distances")
        
        elif isinstance(error, PrecisionError):
            print("   ‚Ä¢ La pr√©cision demand√©e ne peut pas √™tre atteinte")
            print("   ‚Ä¢ V√©rifiez la qualit√© des observations")
            print("   ‚Ä¢ Consid√©rez une re-mesure des segments probl√©matiques")
        
        else:
            print("   ‚Ä¢ Consultez la documentation")
            print("   ‚Ä¢ V√©rifiez les donn√©es d'entr√©e")
            print("   ‚Ä¢ Contactez le support technique si le probl√®me persiste")
        
        sys.exit(1)


def create_sample_data():
    """Cr√©e un fichier d'exemple pour les tests."""
    sample_data = pd.DataFrame({
        'Matricule': ['R001', 'P001', 'P002', 'P003', 'P004', 'R001'],
        'AR 1': [1.2345, 1.5678, 1.8901, 2.1234, 1.4567, 1.7890],
        'AV 1': [1.5678, 1.8901, 2.1234, 1.4567, 1.7890, 2.0123],
        'AR 2': [1.2346, 1.5679, 1.8902, 2.1235, 1.4568, 1.7891],
        'AV 2': [1.5679, 1.8902, 2.1235, 1.4568, 1.7891, 2.0124],
        'DIST 1': [125.50, 147.20, 198.75, 156.30, 173.85, 164.60],
        'DIST 2': [125.50, 147.20, 198.75, 156.30, 173.85, 164.60]
    })
    
    output_path = Path("exemple_donnees_nivellement.xlsx")
    sample_data.to_excel(output_path, index=False)
    
    print(f"üìã Fichier d'exemple cr√©√©: {output_path}")
    print(f"   ‚Ä¢ Cheminement ferm√© (R001 ‚Üí P001 ‚Üí P002 ‚Üí P003 ‚Üí P004 ‚Üí R001)")
    print(f"   ‚Ä¢ 6 points, 2 instruments, distances incluses")
    print(f"   ‚Ä¢ Utilisable pour tester l'application")
    
    return output_path


def main():
    """Fonction principale avec interface en ligne de commande."""
    parser = argparse.ArgumentParser(
        description="Syst√®me de Compensation Altim√©trique - Pr√©cision 2mm",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemples d'utilisation:

  Mode interactif:
    python main.py

  Mode batch:
    python main.py -f donnees.xlsx -a 125.456

  Mode batch avec cheminement ouvert:
    python main.py -f donnees.xlsx -a 125.456 -af 127.123

  Cr√©er fichier d'exemple:
    python main.py --create-sample

  Pr√©cision personnalis√©e:
    python main.py -f donnees.xlsx -a 125.456 --precision 1.0
        """)
    
    # Arguments principaux
    parser.add_argument('-f', '--file', type=Path,
                       help='Fichier de donn√©es Excel/CSV')
    parser.add_argument('-a', '--initial-altitude', type=float,
                       help='Altitude initiale de r√©f√©rence (m√®tres)')
    parser.add_argument('-af', '--final-altitude', type=float,
                       help='Altitude finale connue (cheminements ouverts)')
    parser.add_argument('-o', '--output', type=Path,
                       help='Dossier de sortie (d√©faut: ./results)')
    
    # Options avanc√©es
    parser.add_argument('--precision', type=float, default=2.0,
                       help='Pr√©cision cible en mm (d√©faut: 2.0)')
    parser.add_argument('--no-atmospheric', action='store_true',
                       help='D√©sactiver les corrections atmosph√©riques')
    parser.add_argument('--temperature', type=float, default=28.0,
                       help='Temp√©rature ambiante en ¬∞C (d√©faut: 28.0)')
    parser.add_argument('--pressure', type=float, default=1010.0,
                       help='Pression atmosph√©rique en hPa (d√©faut: 1010.0)')
    parser.add_argument('--create-sample', action='store_true',
                       help='Cr√©er un fichier d\'exemple et quitter')
    parser.add_argument('--no-visualizations', action='store_true',
                       help='D√©sactiver la g√©n√©ration des graphiques')
    
    # Options de d√©bogage
    parser.add_argument('-v', '--verbose', action='store_true',
                       help='Mode verbeux')
    parser.add_argument('--version', action='version',
                       version='Compensation Altim√©trique v1.0 (Modularis√©)')
    
    args = parser.parse_args()
    
    # Cas sp√©ciaux
    if args.create_sample:
        create_sample_data()
        return
    
    # Validation des arguments
    if args.file and not args.initial_altitude:
        parser.error("L'altitude initiale (-a) est requise avec le fichier (-f)")
    
    # Initialisation de l'application
    try:
        app = LevelingApplication(precision_mm=args.precision)
        
        # Configuration des visualisations
        app.enable_visualizations = not args.no_visualizations
        
        if args.file:
            # Mode batch
            app.run_batch(
                input_file=args.file,
                initial_altitude=args.initial_altitude,
                final_altitude=args.final_altitude,
                output_dir=args.output
            )
        else:
            # Mode interactif
            app.run_interactive()
    
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è Interruption utilisateur. Arr√™t du programme.")
        sys.exit(0)
    except Exception as e:
        print(f"\n‚ùå Erreur inattendue: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


def run_quick_demo():
    """D√©monstration rapide avec donn√©es synth√©tiques."""
    print("üöÄ D√âMONSTRATION RAPIDE")
    print("="*50)
    
    # Cr√©er donn√©es d'exemple
    sample_file = create_sample_data()
    
    # Traitement automatique
    app = LevelingApplication(precision_mm=2.0)
    app.run_batch(
        input_file=sample_file,
        initial_altitude=100.000,
        output_dir=Path("demo_results")
    )
    
    print("\nüéØ D√©monstration termin√©e!")
    print("üìÅ Consultez le dossier 'demo_results' pour les r√©sultats")


if __name__ == "__main__":
    # V√©rifier si on veut la d√©mo rapide
    if len(sys.argv) == 2 and sys.argv[1] == "--demo":
        run_quick_demo()
    else:
        main()