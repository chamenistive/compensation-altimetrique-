#!/usr/bin/env python3
"""
Script de test des nouvelles visualisations modernis√©es.
D√©montre les capacit√©s des graphiques statiques et interactifs.

Utilisation:
    python test_visualizations.py
"""

import sys
import numpy as np
from pathlib import Path

# Ajouter le dossier src au PATH
sys.path.append(str(Path(__file__).parent / "src"))

try:
    from visualizer import LevelingVisualizer, COLORS, PLOTLY_AVAILABLE
    print("‚úÖ Visualizer charg√© avec succ√®s")
    
    # Cr√©er des classes de d√©monstration si les modules ne sont pas disponibles
    try:
        from calculator import (
            CalculationResults, AltitudeCalculation, HeightDifference, 
            ClosureAnalysis, TraverseType
        )
        from compensator import CompensationResults, CompensationStatistics
        print("‚úÖ Modules backend charg√©s")
    except ImportError:
        print("‚ö†Ô∏è Modules backend non disponibles - utilisation des classes de d√©mo")
        
        # Classes de d√©monstration simplifi√©es
        from dataclasses import dataclass
        from typing import List
        from enum import Enum
        
        @dataclass
        class AltitudeCalculation:
            point_id: str
            altitude_m: float
            cumulative_delta_h: float
            is_reference: bool = False
        
        @dataclass  
        class HeightDifference:
            delta_h_m: float
            ar_reading: float
            av_reading: float
            instrument_id: int
            is_valid: bool = True
            control_residual: float = None
        
        class TraverseType(Enum):
            CLOSED = "ferm√©"
            OPEN = "ouvert" 
            UNKNOWN = "ind√©termin√©"
            
        @dataclass
        class ClosureAnalysis:
            traverse_type: TraverseType
            closure_error_m: float
            closure_error_mm: float
            tolerance_mm: float
            total_distance_km: float
            is_acceptable: bool
            precision_ratio: float
            
        @dataclass
        class CalculationResults:
            height_differences: List[HeightDifference]
            altitudes: List[AltitudeCalculation]
            closure_analysis: ClosureAnalysis
            control_statistics: dict
            calculation_metadata: dict = None
            
        @dataclass
        class CompensationStatistics:
            sigma_0_hat: float
            degrees_of_freedom: int
            chi2_test_statistic: float
            chi2_critical_value: float
            unit_weight_valid: bool
            max_standardized_residual: float
            blunder_detection_threshold: float
            
        @dataclass
        class CompensationResults:
            adjusted_altitudes: List[AltitudeCalculation]
            adjusted_coordinates: any
            covariance_matrix: any
            residuals: any
            statistics: CompensationStatistics
            solution_method: str
            computation_metadata: dict

    print("‚úÖ Toutes les classes pr√™tes pour les tests")
except ImportError as e:
    print(f"‚ùå Erreur d'import critique: {e}")
    print("üí° V√©rifiez que src/visualizer.py existe")
    sys.exit(1)

def create_demo_data():
    """Cr√©e des donn√©es de d√©monstration pour les tests."""
    print("üîß G√©n√©ration des donn√©es de d√©monstration...")
    
    # Points de nivellement factices
    point_ids = ['RN001', 'P001', 'P002', 'P003', 'P004', 'RN002']
    base_altitude = 125.456  # m
    
    # Altitudes avec une l√©g√®re pente et du bruit
    altitudes = []
    cumulative_delta = 0.0
    for i, point_id in enumerate(point_ids):
        # Pente de 2mm/point + bruit al√©atoire de ¬±0.5mm
        altitude = base_altitude + (i * 0.002) + np.random.normal(0, 0.0005)
        if i > 0:
            cumulative_delta += altitude - altitudes[-1].altitude_m
        altitudes.append(AltitudeCalculation(
            point_id=point_id,
            altitude_m=altitude,
            cumulative_delta_h=cumulative_delta,
            is_reference=(i == 0 or i == len(point_ids)-1)
        ))
    
    # D√©nivel√©es entre points
    height_differences = []
    for i in range(len(altitudes) - 1):
        delta_h = altitudes[i+1].altitude_m - altitudes[i].altitude_m
        # Ajouter une petite erreur syst√©matique
        delta_h += np.random.normal(0, 0.0008)
        
        height_differences.append(HeightDifference(
            delta_h_m=delta_h,
            ar_reading=np.random.uniform(1.2, 1.8),  # Lecture arri√®re simul√©e
            av_reading=np.random.uniform(1.2, 1.8),  # Lecture avant simul√©e
            instrument_id=i,
            is_valid=True
        ))
    
    # Analyse de fermeture
    total_distance = len(height_differences) * 200  # Distance simul√©e 200m par section
    closure_error = np.random.normal(0, 0.003)  # ¬±3mm d'erreur
    
    tolerance_mm = np.sqrt(total_distance / 1000) * 8  # 8mm/‚àökm
    closure_analysis = ClosureAnalysis(
        traverse_type=TraverseType.CLOSED,
        closure_error_m=closure_error,
        closure_error_mm=closure_error * 1000,
        tolerance_mm=tolerance_mm,
        total_distance_km=total_distance / 1000,
        is_acceptable=abs(closure_error * 1000) <= tolerance_mm,
        precision_ratio=abs(closure_error * 1000) / tolerance_mm if tolerance_mm > 0 else 0
    )
    
    # R√©sultats des calculs
    calculation_results = CalculationResults(
        height_differences=height_differences,
        altitudes=altitudes,
        closure_analysis=closure_analysis,
        control_statistics={'demo_mode': True},
        calculation_metadata={
            'method': 'demo',
            'timestamp': '2025-08-28',
            'precision_target_mm': 2.0
        }
    )
    
    print(f"   üìä {len(altitudes)} points g√©n√©r√©s")
    print(f"   üìè {len(height_differences)} d√©nivel√©es")
    print(f"   üéØ Erreur de fermeture: {closure_error*1000:.1f}mm")
    
    return calculation_results

def create_demo_compensation_results(calculation_results):
    """Cr√©e des r√©sultats de compensation factices."""
    print("‚öñÔ∏è G√©n√©ration des r√©sultats de compensation...")
    
    n_points = len(calculation_results.altitudes)
    
    # Corrections simul√©es (compensation par moindres carr√©s)
    corrections = np.random.normal(0, 0.001, n_points)  # ¬±1mm
    
    # Altitudes ajust√©es
    adjusted_altitudes = []
    for i, alt in enumerate(calculation_results.altitudes):
        adjusted_altitudes.append(AltitudeCalculation(
            point_id=alt.point_id,
            altitude_m=alt.altitude_m + corrections[i],
            cumulative_delta_h=alt.cumulative_delta_h,
            is_reference=alt.is_reference
        ))
    
    # Matrice de covariance simul√©e
    covariance_matrix = np.eye(n_points) * (0.0015**2)  # 1.5mm d'√©cart-type
    # Ajouter des corr√©lations
    for i in range(n_points-1):
        covariance_matrix[i, i+1] = covariance_matrix[i+1, i] = 0.0008**2
    
    # Statistiques de compensation
    residuals = np.random.normal(0, 0.0008, n_points)
    dof = n_points - 2
    statistics = CompensationStatistics(
        sigma_0_hat=1.12,
        degrees_of_freedom=dof,
        chi2_test_statistic=dof * 1.12**2,
        chi2_critical_value=9.488,  # Chi¬≤ critique pour Œ±=0.05
        unit_weight_valid=True,
        max_standardized_residual=np.max(np.abs(residuals)) / 0.0015,
        blunder_detection_threshold=2.5
    )
    
    # R√©sultats de compensation
    compensation_results = CompensationResults(
        adjusted_altitudes=adjusted_altitudes,
        adjusted_coordinates=corrections.reshape(-1, 1),
        covariance_matrix=covariance_matrix,
        residuals=residuals.reshape(-1, 1),
        statistics=statistics,
        solution_method="LSQ",
        computation_metadata={
            'iterations': 3,
            'convergence_threshold': 1e-8,
            'max_correction_mm': np.max(np.abs(corrections)) * 1000,
            'condition_number': 1.2e3,
            'blunder_detection': {'suspect_count': 0, 'outliers': []},
            'timestamp': '2025-08-28'
        }
    )
    
    print(f"   üîß Corrections max: {np.max(np.abs(corrections))*1000:.1f}mm")
    print(f"   üìà œÉ‚ÇÄ: {statistics.sigma_0_hat:.3f}")
    
    return compensation_results

def test_matplotlib_visualizations():
    """Teste les visualisations matplotlib modernis√©es."""
    print("\nüé® === TEST VISUALISATIONS MATPLOTLIB MODERNES ===")
    
    # Donn√©es de test
    calculation_results = create_demo_data()
    compensation_results = create_demo_compensation_results(calculation_results)
    
    # Cr√©er le visualiseur
    visualizer = LevelingVisualizer(precision_mm=2.0, output_dir=Path("./test_visualizations"))
    
    try:
        # 1. Profil altim√©trique
        print("\nüìà Test profil altim√©trique...")
        profile_path = visualizer.create_altitude_profile(
            calculation_results, 
            compensation_results, 
            show_corrections=True
        )
        print(f"   ‚úÖ Cr√©√©: {profile_path}")
        
        # 2. Analyse de fermeture
        print("\nüéØ Test analyse de fermeture...")
        closure_path = visualizer.create_closure_analysis_plot(
            calculation_results.closure_analysis, 
            calculation_results
        )
        print(f"   ‚úÖ Cr√©√©: {closure_path}")
        
        # 3. Diagnostics de compensation
        print("\n‚öôÔ∏è Test diagnostics compensation...")
        diagnostics_path = visualizer.create_compensation_diagnostics(
            compensation_results, 
            calculation_results
        )
        print(f"   ‚úÖ Cr√©√©: {diagnostics_path}")
        
        # 4. Carte de pr√©cision
        print("\nüó∫Ô∏è Test carte de pr√©cision...")
        precision_path = visualizer.create_precision_map(
            compensation_results, 
            calculation_results
        )
        print(f"   ‚úÖ Cr√©√©: {precision_path}")
        
        print(f"\nüìä {len(visualizer.get_created_plots())} graphiques matplotlib cr√©√©s")
        
    except Exception as e:
        print(f"‚ùå Erreur matplotlib: {e}")
        return False
    
    return True

def test_plotly_visualizations():
    """Teste les visualisations Plotly interactives."""
    print("\nüåê === TEST VISUALISATIONS PLOTLY INTERACTIVES ===")
    
    if not PLOTLY_AVAILABLE:
        print("‚ö†Ô∏è Plotly non install√© - tests interactifs ignor√©s")
        print("üí° Installez avec: pip install plotly kaleido")
        return False
    
    # Donn√©es de test
    calculation_results = create_demo_data()
    compensation_results = create_demo_compensation_results(calculation_results)
    
    # Cr√©er le visualiseur
    visualizer = LevelingVisualizer(precision_mm=2.0, output_dir=Path("./test_visualizations"))
    
    try:
        # 1. Profil interactif
        print("\nüèîÔ∏è Test profil altim√©trique interactif...")
        interactive_profile = visualizer.create_interactive_altitude_profile(
            calculation_results, 
            compensation_results
        )
        if interactive_profile:
            print(f"   ‚úÖ Cr√©√©: {interactive_profile}")
            print(f"   üåê Ouvrez dans votre navigateur: file://{interactive_profile.absolute()}")
        
        # 2. Dashboard interactif
        print("\nüìä Test dashboard interactif...")
        dashboard = visualizer.create_interactive_dashboard(
            calculation_results, 
            compensation_results
        )
        if dashboard:
            print(f"   ‚úÖ Cr√©√©: {dashboard}")
            print(f"   üåê Ouvrez dans votre navigateur: file://{dashboard.absolute()}")
        
        print(f"\nüéØ Visualisations interactives HTML disponibles!")
        
    except Exception as e:
        print(f"‚ùå Erreur Plotly: {e}")
        return False
    
    return True

def test_color_palette():
    """Teste et affiche la palette de couleurs g√©od√©siques."""
    print("\nüé® === TEST PALETTE COULEURS G√âOD√âSIQUES ===")
    
    print("Couleurs principales:")
    for name, color in COLORS.items():
        if not name.endswith('_light'):  # √âviter les doublons
            print(f"   {name:20} : {color}")
    
    # Test avec matplotlib si disponible
    try:
        import matplotlib.pyplot as plt
        import matplotlib.patches as mpatches
        
        fig, ax = plt.subplots(figsize=(12, 8))
        
        # Cr√©er des patches color√©s
        y_pos = 0
        patches = []
        labels = []
        
        for name, color in COLORS.items():
            if not name.endswith('_light'):
                rect = mpatches.Rectangle((0, y_pos), 2, 0.8, 
                                        facecolor=color, edgecolor='black')
                ax.add_patch(rect)
                ax.text(2.1, y_pos + 0.4, f"{name}: {color}", 
                       va='center', fontsize=11, fontfamily='monospace')
                y_pos += 1
        
        ax.set_xlim(0, 8)
        ax.set_ylim(0, y_pos)
        ax.set_title('üé® Palette de Couleurs G√©od√©siques Moderne', 
                    fontsize=16, fontweight='bold')
        ax.axis('off')
        
        # Sauvegarde
        palette_path = Path("./test_visualizations/palette_couleurs.png")
        palette_path.parent.mkdir(exist_ok=True)
        plt.savefig(palette_path, dpi=150, bbox_inches='tight')
        plt.close()
        
        print(f"   ‚úÖ Palette sauvegard√©e: {palette_path}")
        
    except Exception as e:
        print(f"   ‚ö†Ô∏è Impossible de cr√©er la palette visuelle: {e}")

def main():
    """Fonction principale de test."""
    print("üßÆ === TEST COMPLET VISUALISATIONS MODERNIS√âES ===")
    print("Syst√®me de Compensation Altim√©trique - Nouvelles Visualisations")
    print("=" * 60)
    
    # Test de la palette
    test_color_palette()
    
    # Tests matplotlib
    matplotlib_ok = test_matplotlib_visualizations()
    
    # Tests Plotly
    plotly_ok = test_plotly_visualizations()
    
    # R√©sum√©
    print("\n" + "=" * 60)
    print("üéØ R√âSUM√â DES TESTS")
    print(f"   üìä Matplotlib (statique): {'‚úÖ OK' if matplotlib_ok else '‚ùå ERREUR'}")
    print(f"   üåê Plotly (interactif): {'‚úÖ OK' if plotly_ok else '‚ö†Ô∏è NON TEST√â'}")
    
    # Instructions
    if matplotlib_ok or plotly_ok:
        print("\nüìÅ Fichiers g√©n√©r√©s dans: ./test_visualizations/")
        print("üí° Pour les graphiques HTML, ouvrez-les dans votre navigateur")
        if plotly_ok:
            print("üéÆ Les graphiques Plotly sont interactifs: zoom, hover, export PNG")
    
    print("\nüéâ Tests termin√©s!")

if __name__ == "__main__":
    main()